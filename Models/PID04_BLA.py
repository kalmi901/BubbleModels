# PID = 04 (Keller-Miksis equation)
# BLA = Boundary layer approximation (Sperical stability)
# TODO: ADD description Here
from scipy.integrate import solve_ivp
import math


def Solve(p, op, ec, e=None):
    return solve_ivp(__PID04_ODE,
                     op.TimeDomain,
                     op.InitialCondition,
                     method='RK45',
                     dense_output=False,
                     events=e,
                     args=(ec,),
                     rtol=op.RelativeTolerance,
                     atol=op.AbsoluteTolerance)


def __PID04_ODE(t, x, ec):
    # ODE Function
    dx = [0 for _ in range(0, 4)]
    rx1 = 1.0 / x[0]
    p = rx1**ec[10]
    s1 = math.sin(2.0 * math.pi * t)
    c1 = math.cos(2.0 * math.pi * t)
    s2 = math.sin(2.0 * ec[11] * math.pi * t + ec[12])
    c2 = math.cos(2.0 * ec[11] * math.pi * t + ec[12])

    n = (ec[0] + ec[1] * x[1]) * p - ec[2] * (1.0 + ec[9] * x[1]) - ec[3] * rx1 - ec[4] * x[1] * rx1 - 1.5 * (
            1.0 - ec[9] * x[1] / 3.0) * x[1] * x[1] - (ec[5] * s1 + ec[6] * s2) * (1.0 + ec[9] * x[1]) - x[0] * (
                ec[7] * c1 + ec[8] * c2)
    d = x[0] - ec[9] * x[0] * x[1] + ec[4] * ec[9]
    rd = 1.0 / d
    dx[0] = x[1]
    dx[1] = n * rd

    # BLA

    C1 = ec[15] - 1
    C2 = ec[15] * (ec[15] + 2)**2
    C3 = ec[15] * (ec[15] - 1) * (ec[15] + 2)
    C4 = (ec[15] - 1) * (ec[15] + 1) * (ec[15] + 2)

    BL = min(max(ec[16], ec[17]), x[0] * ec[14] / (2 * ec[15]))
    D = 2 * BL / (x[0] * ec[14])

    A = - C1 * dx[1] * rx1 + C4 * 0.5 * ec[3] * rx1**3 + 0.5 * ec[4] * x[1] * rx1**3 * (C4 - C3 / (1 + D))
    B = 3 * x[1] * rx1 + 0.5 * ec[4] * rx1**2 * (C2 / (1 + D) - C4)

    dx[2] = x[3]
    dx[3] = - B * x[3] - A * x[2]
    return dx


def GetEquationConstants(p):
    # Covert variables to SI
    # Pressures
    p_inf = p.P7 * 1e5  # ambient pressure [Pa]
    pa1 = p.P1 * 1e5  # Pressure Amplitude1 [Pa]
    pa2 = p.P3 * 1e5  # Pressure Amplitude2 [Pa]

    # Frequencies
    f1 = 2 * math.pi * p.P2 * 1000  # angular frequency1 [rad/s]
    f2 = 2 * math.pi * p.P4 * 1000  # angular frequency2 [rad/s]
    ec = [0 for _ in range(0, 18)]

    ec[0] = (2 * p.Material.ST / p.P6 + p_inf - p.Material.Pv) * \
            (2.0 * math.pi / p.P6 / f1) ** 2 / p.Material.Rho
    ec[1] = (1 - 3.0 * p.P9) * (2 * p.Material.ST / p.P6 + p_inf - p.Material.Pv) * \
            (2.0 * math.pi / p.P6 / f1) / p.Material.CL / p.Material.Rho
    ec[2] = (p_inf - p.Material.Pv) * (2.0 * math.pi / p.P6 / f1) ** 2 / p.Material.Rho
    ec[3] = (2 * p.Material.ST / p.P6 / p.Material.Rho) * (2.0 * math.pi / p.P6 / f1) ** 2
    ec[4] = (4 * p.Material.Vis / p.Material.Rho / p.P6 ** 2) * (2.0 * math.pi / f1)
    ec[5] = pa1 * (2.0 * math.pi / p.P6 / f1) ** 2 / p.Material.Rho
    ec[6] = pa2 * (2.0 * math.pi / p.P6 / f1) ** 2 / p.Material.Rho
    ec[7] = (p.P6 * f1 * pa1 / p.Material.Rho / p.Material.CL) * (2.0 * math.pi / p.P6 / f1) ** 2
    ec[8] = (p.P6 * f2 * pa2 / p.Material.Rho / p.Material.CL) * (2.0 * math.pi / p.P6 / f1) ** 2
    ec[9] = p.P6 * f1 / (2.0 * math.pi) / p.Material.CL
    ec[10] = 3.0 * p.P9
    ec[11] = p.P4 / p.P2
    ec[12] = p.P5
    ec[13] = 2.0 * math.pi / f1  # t_ref
    ec[14] = p.P6  # R_ref
    ec[15] = p.Mode
    ec[16] = (p.Material.Vis/p.Material.Rho/f1)**0.5 if pa1 != 0 else 0  # boundary layer thickness generated by f1
    ec[17] = (p.Material.Vis/p.Material.Rho/f2)**0.5 if pa2 != 0 else 0  # boundary layer thickness generated by f2

    return tuple(ec)
